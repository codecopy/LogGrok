using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Linq.Expressions;
using System.IO;
using System.Text;
using System.Collections.Concurrent;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

using LogGrok.Core;
using LogGrok.LogParserBase;
using LogGrok.Macros;
using LogGrok.Unsafe;

namespace LogGrok.Module.CommonLogs
{
    [Disposable]
    internal class RegexBasedLineReader : ILineReader
    {
        [Record]
        internal class RegexBasedLine : Line
        {
            public override Item[s : string] : object
            {
                get
                {
                    mutable groupNum;
                    if (_groupNameMapping.TryGetValue(s, out groupNum))
                    {
                        def start = _groups[groupNum*2 + _groupsOffset ];
                        def len = _groups[groupNum*2 + 1 + _groupsOffset ];
                        LogGrok.Core.StringText(_stringBuffer, start, len)
                    }
                    else
                        Text.Empty;
                }
            }

            [RecordIgnore]
            public override Time : System.TimeSpan
            {
                get; set;
            }

            public override GetRawLine() : string
            {
                _stringBuffer.Substring(_groups[_groupsOffset], _groups[_groupsOffset + 1])
            }
            
            public override ToString(): string
            {
                GetRawLine() 
            }

            public Clone() : RegexBasedLine
            {
                def groups = List.[int]();
                def builder = StringBuilder();
                def strings = _groupNameMapping.Select(kv => this[kv.Key].ToString());
                
                mutable current = 0;
                foreach(str in strings)
                {
                    builder.Append(str);
                    groups.Add(current);
                    groups.Add(str.Length);
                    current += str.Length;
                }
                
                RegexBasedLine(builder.ToString(), groups.ToArray(), 0, _groupNameMapping)
            }            
            
            private _stringBuffer : string;
            private _groups : array[int];
            private _groupsOffset : int;
            private _groupNameMapping : Dictionary[string, int];
        }

        public this([NotNull] streamFactory : void -> Stream, encoding : System.Text.Encoding, regexes : list[Regex], meta : MetaInformation)
        {
            _stream = streamFactory();
            _meta = meta;
            _encoding = encoding;
            _parser = LogGrok.Unsafe.BufferParser(encoding, regexes.ToArray());
            _lineStream = streamFactory();
            _regexes    = regexes;
        }

        public GetLastLine() : ILine
        { 
            EmptyLine
        }
        
        private static Combine[T, U](this source : IEnumerable[T], convert : T -> U, needCombine : T -> bool, combine : (U*T) -> U) : IEnumerable[U]
        {
            def enumerator = source.GetEnumerator();
            when (enumerator.MoveNext())
            {
                mutable current = convert(enumerator.Current);    
                while(enumerator.MoveNext())
                {
                    if (needCombine(enumerator.Current))
                    {
                        current = combine(current, enumerator.Current);
                        
                    }
                    else
                    {
                        yield current;
                        current = convert(enumerator.Current);
                    }
                }
                
                yield current;
            }
           
        }
        
        private ParseLine(s : string, offset : int*int) : option[Line]
        {
            def (begin, len) = offset;
            def Parse(regexes)
            {
                | regex :: _ =>
                    def m = regex.Match(s, begin, len);
                    if (!m.Success)
                    {
                        None()
                    }
                    else
                    {
                        def mapping = GetGroupNamesMapping(regex);
                        def groupCount = mapping.Count;
                        def groups = array(groupCount*2);
                        mutable current =0;
                        foreach(group : Group in m.Groups)
                        {
                            groups[current] = group.Index;
                            groups[current+1] = group.Length;
                            current+=2;
                        }
                    
                        Some(RegexBasedLine(s, groups,0, mapping))
                    }
                | _ => None()
            }
            
            Parse(_regexes)
        }
        
        private SkipPreamble() : void
        {
            _stream.Position = 0;
            def preamble = _encoding.GetPreamble();
            def preambleBuffer = array(preamble.Length);
            def read = _stream.Read(preambleBuffer, 0, preambleBuffer.Length);
            
            when (read < preambleBuffer.Length || !LogGrok.Unsafe.ByteArrayTools.FastEquals(preamble, 0, preambleBuffer, 0, preamble.Length))
            {
                _stream.Position = 0;
            }            
        }
        
        private FindNextLineStart(buffer : array[byte], searchFrom : int) : int
        {
            def crSize = _encoding.GetBytes("\r").Length;
            def r = _encoding.GetBytes("\r");
            def n = _encoding.GetBytes("\n");
            
            def Find(position, crlfFound)
            {
                if (position == buffer.Length -1)
                    position + crSize
                else
                {
                    def isCrlf = ByteArrayTools.FastEquals(buffer, position, r, 0, crSize) 
                                || ByteArrayTools.FastEquals(buffer, position, n, 0, crSize);
                    match(isCrlf, crlfFound)
                    {
                        | (false, true) => position
                        | _             => Find(position + crSize, isCrlf)
                    }
                }
            }
            
            Find(searchFrom, false)                        
        }

        private ParseBuffer(parser : BufferParser, buffer : array[byte], len : int) : list[BufferParser.Result]*int
        {
            def partSize = 1024*1024;
            def GetParts(position, partList)
            {
                if (len - position < partSize)
                {
                    (position, len - position) :: partList
                }
                else
                {
                    def nextPartStart = FindNextLineStart(buffer, position + partSize);
                    def newPartList = (position, nextPartStart - position) :: partList;
                    GetParts(nextPartStart, newPartList)
                }
            }
            
            def parts = GetParts(0, []).Reverse().ToArray();            
            
            def resArray = array(parts.Length);
            Parallel.For(0, parts.Length,
                i =>
                {
                    def part = parts[i];
                    def (start, length) = part;
                    def result = parser.ParseBuffer(buffer, start, length); 
                    resArray[i] = result;          
                });
            
            def lastResult = resArray.Last(r => r.ResultCount > 0);
            (NList.ToList(resArray), lastResult.LastBytePosition)            
        }
        
        private readLength = 4*1024*1024;
        private bufferPool : SimpleObjectPool[array[byte]] = SimpleObjectPool.[array[byte]](() => array(readLength));
        
        private ReadAndParseCore(parser : BufferParser, collection : BlockingCollection[array[byte]*list[BufferParser.Result]*long]) : void
        {
            mutable position = _stream.Position;
            def crSize = _encoding.GetBytes("\r").Length;
           
            while (position < _stream.Length - crSize)
            {
                def byteBuffer = bufferPool.Get();
                def bytesRead = _stream.Read(byteBuffer, 0, byteBuffer.Length);
                def (results, end) = ParseBuffer(parser, byteBuffer, bytesRead);
                
                if (end < bytesRead && bytesRead < readLength)
                    _stream.Position= position + end;
                else
                    _stream.Position = position + bytesRead;

                collection.Add((byteBuffer, results, position));
                position = _stream.Position;
            };
            collection.CompleteAdding();
        }
        
        private ReadAndParse() : BlockingCollection[array[byte]*list[BufferParser.Result]*long]
        {
            def collection = BlockingCollection.[array[byte]*list[BufferParser.Result]*long](2);
            SkipPreamble();                
            _ = Task.Factory.StartNew(() => ReadAndParseCore(_parser, collection), TaskCreationOptions.LongRunning);
            collection
        }
        
        public GetEnumerator() : IEnumerator[Line]
            implements IEnumerable.[Line].GetEnumerator
        { 
            foreach((buffer, results, position) in ReadAndParse().GetConsumingEnumerable())
            {
                foreach(result in results)
                {
                    using (result)
                    {
                        for (mutable idx =0; idx < result.ResultCount; idx ++)
                        {
                            def lineStart = result.GetLineStart(idx);
                            def lineLength = result.GetLineLength(idx);

                            def stringBuffer = result.StringBuffer;
                            def stringIndices = result.StringIndices;
                            def indicesOffset = result.GetStringIndicesOffset(idx);
                            def groupNameMapping = result.GetGroupNameMapping(idx); 
                            def beginOffset = lineStart :> long + position;
                            def endOffset = lineLength :> long + beginOffset;
                            
                            def line = RegexBasedLine(stringBuffer, stringIndices, indicesOffset, groupNameMapping)
                                <- { Offset = beginOffset; EndOffset = endOffset; }; 
                            yield line
                        }
                    }
                    bufferPool.Release(buffer);
                }
            }
            
        }

        public NonGenericGetEnumerator() : IEnumerator
            implements IEnumerable.GetEnumerator
        { 
            (this : ILineReader).GetEnumerator() 
        }
        
        private static ReadTextAt(encoding : System.Text.Encoding, stream : Stream, beginOffset : long, endOffset : long) : string*array[byte]
        {
            def length = (endOffset - beginOffset) :> int;

            def buffer    = array(length);

            stream.Position = beginOffset;
            def bytesRead = stream.Read(buffer, 0, length);
            
            (encoding.GetString(buffer, 0, bytesRead).TrimEnd(System.Environment.NewLine.ToCharArray()), buffer);
        }

        public ReadLineAt(beginOffset : long, endOffset : long) : LogGrok.Core.ILine
        {
            def (str, buffer) = ReadTextAt(_encoding, _lineStream, beginOffset, endOffset);
            def parser = LogGrok.Unsafe.BufferParser(_encoding, _regexes.ToArray());
            using(def result = _parser.ParseBuffer(buffer))
            {
                if (result.ResultCount < 1)
                {
                    EmptyLine
                }
                else
                {
                    def lineStart = result.GetLineStart(0);
                    def lineLength = result.GetLineLength(0);

                    def stringBuffer = result.StringBuffer;
                    def stringIndices = result.StringIndices;
                    def indicesOffset = result.GetStringIndicesOffset(0);
                    def groupNameMapping = result.GetGroupNameMapping(0); 
                        
                    RegexBasedLine(stringBuffer, stringIndices, indicesOffset, groupNameMapping).Clone();
                }
            }
                //}    for (mutable idx =0; idx < result.ResultCount; idx ++)
                //    {
                //        def lineStart = result.GetLineStart(idx);
                //        def lineLength = result.GetLineLength(idx);

                //        def stringBuffer = result.StringBuffer;
                //        def stringIndices = result.StringIndices;
                //        def indicesOffset = result.GetStringIndicesOffset(idx);
                //        def groupNameMapping = result.GetGroupNameMapping(idx); 
                //        def beginOffset = lineStart :> long + position;
                //        def endOffset = lineLength :> long + beginOffset;
                        
                //        yield RegexBasedLine(stringBuffer, stringIndices, indicesOffset, groupNameMapping)
                //            <- { Offset = beginOffset; EndOffset = endOffset; };

            //match(ParseLine(str, (0, str.Length)))
            //{
            //    | Some(line) => line <- { Offset = beginOffset; EndOffset = endOffset; };
            //    | _ => EmptyLine
            //}
        }

        private static GetFieldAccessor[T,R](fieldName : string ) : Func[T,R]
        { 
            def param = Expression.Parameter (typeof(T),"arg");  

            def member = Expression.Field(param, fieldName);   

            def lambda = Expression.Lambda(typeof(Func[T,R]), member, param);   

            lambda.Compile() :> Func[T,R]; 
        }

        [Memoize]
        private GetGroupNamesMapping(regex : Regex) : Dictionary[string, int]
        {
            Enumerable.Zip(regex.GetGroupNames(), regex.GetGroupNumbers(), (name, num)=> (name, num)).ToDictionary(n => n[0], n => n[1]);
        }
        

        private class EmptyLinePrivate : Line
        {
            public override Item[_ : string] : object { get { Text.Empty } }

            public override Time : System.TimeSpan { get; set; }

            public override GetRawLine() : string { string.Empty }
        }
               
        private _lineStream : Stream;
        private _stream : Stream;
        private _encoding : Encoding;
        private _parser : LogGrok.Unsafe.BufferParser;
        private _regexes      : list[Regex];
        private _meta         : MetaInformation;
        private _matchesGetter : Func[Match, array[array[int]]] = GetFieldAccessor.[Match, array[array[int]]]("_matches");
        
        public static EmptyLine : Line = EmptyLinePrivate();
    }
}
