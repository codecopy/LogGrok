using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

using LogGrok.Unsafe;
using System.Threading;

namespace LogGrok.Core
{
    public module TextTools
    {
        public Empty : Text
        {
            get { _empty }
        }
        
        private _empty : Text = Text8(0, 0, array(0));
    }
  
    public class StorageProvider[T]
    {
        public this(storageFactory : int -> T, initialSize : int)
        {
            _storageFactory = storageFactory;
            _currentStorageSize = initialSize;
            _currentStorage = storageFactory(_currentStorageSize);
        }
        
        public GetStorage(length : int) : T*int
        {
            if (_begin + length <= _currentStorageSize)
            {
                def result = (_currentStorage, _begin);
                _begin += length;
                result
            }
            else
            {
                when (length > _currentStorageSize)
                    _currentStorageSize = length;
                
                _currentStorage = _storageFactory(_currentStorageSize);
                _begin = length;
                (_currentStorage, 0)
            }
        }
       
        private _storageFactory : int -> T;
        private mutable _currentStorage : T;
        private mutable _currentStorageSize : int;
        private mutable _begin : int;
    }
    
    public interface ITextStorage 
    {
        GetHashCode(begin : int, len : int) : int;
        Equals(begin : int, len : int, otherTextRange: TextRange) : bool;
        ToString(begin : int, len : int) : string;
        CopyToLocalStorage(begin : int, len : int) : TextRange; 
    }
    
    [Record]
    public class StringStorage : ITextStorage
    {
        static this()
        {
            _localStorageProvider = ThreadLocal(() => StorageProvider(size => StringStorage(string('\0', size)), 1024*1024));
        }
        
        public GetHashCode(begin : int, len : int) : int
        {
            _storage.GetHashCode(begin, len);
        }
        
        public Equals(begin : int, len : int, otherTextRange: TextRange) : bool
        {
            if (len != otherTextRange.Length) false
            else
            match (otherTextRange.Storage)
            {
                | otherStorage is StringStorage => 
                    if (len == 0) true
                    else
                    ByteArrayTools.FastEquals(_storage, begin, otherStorage._storage, otherTextRange.Begin, len)
                | _ => false
            }
        }
        
        public ToString(begin : int, len : int) : string
        {
            match (len)
            {
                | 0 => string.Empty;
                | -1 => "Invalid"
                | _ => _storage.Substring(begin, len)
            }
        }
        
        public CopyToLocalStorage(begin : int, len : int) : TextRange
        {
            def (localStorage, storageBegin) = _localStorageProvider.Value.GetStorage(len); 
            _storage.UnsafeCopyTo(begin, localStorage._storage, storageBegin, len);
            TextRange(storageBegin, len, localStorage)
        }

        private static _localStorageProvider : ThreadLocal[StorageProvider[StringStorage]];
        
        private _storage : string;
    }
         
    [Record]
    public class ByteStorage : ITextStorage
    {
        static this()
        {
            _localStorageProvider = ThreadLocal(() => StorageProvider((size) => array(size), 1024*1024));
        }
        public GetHashCode(begin : int, len : int) : int
        {
            _storage.GetModifiedFNVHash(begin, len)
        }
        
        public Equals(begin : int, len : int, otherTextRange: TextRange) : bool
        {
            if (len != otherTextRange.Length) false
            else
            match (otherTextRange.Storage)
            {
                | otherStorage is ByteStorage => 
                    if (len == 0) 
                        true 
                    else
                        ByteArrayTools.FastEquals(_storage, begin, otherStorage._storage, otherTextRange.Begin, len);

                | _ => false
            }
        }
        
        public CopyToLocalStorage(begin : int, len : int) : TextRange
        {
            def (localStorage, storageBegin) = _localStorageProvider.Value.GetStorage(len); 
            Buffer.BlockCopy(_storage, begin, localStorage, storageBegin, len);
            TextRange(storageBegin, len, ByteStorage(localStorage, _encoding))
        }

        private static _localStorageProvider : ThreadLocal[StorageProvider[array[byte]]];
        
        public ToString(begin : int, len : int) : string
        {
            _encoding.GetString(_storage, begin, len);
        }
        
        private _storage : array[byte];
        private _encoding : System.Text.Encoding;
    }

    
    [Record]
    public struct TextRange : IEquatable[TextRange], Text
    {
        public Begin : int;
        public Length: int;
        public Storage : ITextStorage;
        
        public static Empty : TextRange { get { _empty } };

        public static Invalid : TextRange { get { _invalid } };
        
        public static FromString(str : string) : TextRange
        {
            TextRange(0, str.Length, StringStorage(str)).MoveToLocalStorage()
        }
        
        public MoveToLocalStorage() : TextRange
        {
            Storage.CopyToLocalStorage(Begin, Length)
        }
        
        public Equals(other : TextRange) : bool
        {
            Storage.Equals(Begin, Length, other)
        }
        
        public override ToString() : string
        {
            if (Storage == null)
                "Uninitialized"
            else
                Storage.ToString(Begin, Length)
        }
        
        public override GetHashCode() : int
        {
            Storage.GetHashCode(Begin, Length)
        }
        
        public CompareTo(obj : Text) : int 
        {
            this.ToString().CompareTo(obj.ToString())
        }
        
        public CompareTo(obj : object) : int
            implements IComparable[Text].CompareTo
        {
            this.ToString().CompareTo(obj.ToString())
        }

        private static _empty : TextRange = TextRange(0,0, StringStorage(String.Empty));
        private static _invalid : TextRange = TextRange(0, -1, StringStorage(String.Empty));
    }
    
    public interface Text : IComparable, IComparable[Text]
    {
        
        //public static Empty : Text
        //{
        //    get
        //    {
        //        _empty
        //    }
        //}
        
        //public abstract GetHashCode() : int;
        
        //public abstract Equals(other : object) : bool;
        
        //public virtual CompareTo(obj : Text) : int 
        //{
        //    this.ToString().CompareTo(obj.ToString())
        //}
        
        //public NonGenericCompareTo(obj : object) : int 
        //                    implements IComparable.CompareTo
        //{
        //    | text is Text => this.ToString().CompareTo(text.ToString())
        //    | _ => throw ArgumentException("Cannot compare $obj to Text");
        //}

        //private static _empty : Text = Text8(0, 0, array(0));
    }
    
    [Record]
    public class ByteText  : Text
    {
        public Length : int
        {
            get
            {
                _end - _start;
            }
        }
        
        public override GetHashCode() : int 
        {
            _buffer.GetModifiedFNVHash(_start, _end - _start)
        }
        
        public override Equals(other : object) : bool
        {
            | otherText is ByteText =>
            {
                if (Length != otherText.Length)
                    false
                else
                {
                    if (Length == 0) 
                        true 
                    else
                        ByteArrayTools.FastEquals(_buffer, _start, otherText._buffer, otherText._start, Length);
                }
            }
            | _ => false
        }
                
        public CompareTo(obj : Text) : int 
            implements IComparable[Text].CompareTo
        {
            this.ToString().CompareTo(obj.ToString())
        }
        
        public CompareTo(obj : object) : int
        {
            this.ToString().CompareTo(obj.ToString())
        }
        
        public override ToString() : string
        {
            throw InvalidOperationException()
        }
        
        protected ToString(encoding : System.Text.Encoding) : string
        {
            encoding.GetString(_buffer, _start, _end - _start);
        }
        
        private static _empty : Text = Text8(0, 0, array(0));
        
        private _start : int;
        private _end   : int;
        private _buffer : array[byte];
    }
    
    public class TextWithCopy : ByteText//, IComparable, IComparable[Text]
    {
        protected this(start : int, end : int, buffer : array[byte])
        {
            unchecked
            {
                Buffer = array(end - start);
                Buffer.BlockCopy(buffer, start, Buffer, 0, end - start);
                
                base(0, Buffer.Length, Buffer)
            }
        }      
       
        protected Buffer : array[byte];
                
        public override ToString() : string
        {
            throw InvalidOperationException()
        }
        
        private static _empty : Text = Text8(0, 0, array(0));
    }
}
