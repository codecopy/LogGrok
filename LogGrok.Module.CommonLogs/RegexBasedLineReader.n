using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.IO;
using System.Text;
using System.Collections.Concurrent;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

using LogGrok.Core;
using LogGrok.LogParserBase;
using LogGrok.Macros;
using LogGrok.Unsafe;
using LogGrok.Macros.Diagnostics;

namespace LogGrok.Module.CommonLogs
{
    [Disposable]
    internal class RegexBasedLineReader : ILineReader
    {
        [Record]
        internal class RegexBasedLine : Line
        {
            public override Item[s : string] : object
            {
                get
                {
                    mutable groupNum;
                    if (_groupNameMapping.TryGetValue(s, out groupNum))
                    {
                        def start = _groups[groupNum*2 + _groupsOffset ];
                        def len = _groups[groupNum*2 + 1 + _groupsOffset ];
                        def result = LogGrok.Core.StringText(_stringBuffer, start, len);
                        
                        when (result.ToString().Contains(":2"))
                            Console.WriteLine("");
                        result
                    }
                    else
                        Text.Empty;
                }
            }

            [RecordIgnore]
            public override Time : System.TimeSpan
            {
                get; set;
            }

            public override GetRawLine() : string
            {
                _stringBuffer.Substring(_groups[_groupsOffset], _groups[_groupsOffset + 1])
            }
            
            public override ToString(): string
            {
                GetRawLine() 
            }

            public Clone() : RegexBasedLine
            {
                def groups = List.[int]();
                def builder = StringBuilder();
                def strings = _groupNameMapping.Select(kv => this[kv.Key].ToString());
                
                mutable current = 0;
                foreach(str in strings)
                {
                    builder.Append(str);
                    groups.Add(current);
                    groups.Add(str.Length);
                    current += str.Length;
                }
                
                RegexBasedLine(builder.ToString(), groups.ToArray(), 0, _groupNameMapping)
            }            
            
            private _stringBuffer : string;
            private _groups : array[int];
            private _groupsOffset : int;
            private _groupNameMapping : Dictionary[string, int];
        }

        public this([NotNull] streamFactory : void -> Stream, encoding : System.Text.Encoding, regexes : list[Regex], meta : MetaInformation)
        {
            _stream = streamFactory();
            _meta = meta;
            _encoding = encoding;
            //_rBytes = encoding.GetBytes("\r");
            //_nBytes = encoding.GetBytes("\n");
            //_crSize = _rBytes.Length;
            ///_parser = LogGrok.Unsafe.BufferParser3(encoding, regexes.ToArray());
            _lineStream = streamFactory();
            _regexes    = regexes;
        }

        public GetLastLine() : ILine
        { 
            EmptyLine
        }
        
        private ParseLine(s : string, offset : int*int) : option[Line]
        {
            def (begin, len) = offset;
            def Parse(regexes)
            {
                | regex :: _ =>
                    def m = regex.Match(s, begin, len);
                    if (!m.Success)
                    {
                        None()
                    }
                    else
                    {
                        def mapping = GetGroupNamesMapping(regex);
                        def groupCount = mapping.Count;
                        def groups = array(groupCount*2);
                        mutable current =0;
                        foreach(group : Group in m.Groups)
                        {
                            groups[current] = group.Index;
                            groups[current+1] = group.Length;
                            current+=2;
                        }
                    
                        Some(RegexBasedLine(s, groups,0, mapping))
                    }
                | _ => None()
            }
            
            Parse(_regexes)
        }
        
        private SkipPreamble() : void
        {
            _stream.Position = 0;
            def preamble = _encoding.GetPreamble();
            def preambleBuffer = array(preamble.Length);
            def read = _stream.Read(preambleBuffer, 0, preambleBuffer.Length);
            
            when (read < preambleBuffer.Length || !LogGrok.Unsafe.ByteArrayTools.FastEquals(preamble, 0, preambleBuffer, 0, preamble.Length))
            {
                _stream.Position = 0;
            }            
        }
        
        //private FindLastLineStart(buffer : array[byte], searchFrom : int) : int
        //{
        //    def Find(postion)
        //    {
        //        if (position <= 0)
        //        {
        //            // TODO: process this correctly
        //            buffer.Length - 1024
        //        }
        //        else
        //        {
        //            def isCrlf = ByteArrayTools.FastEquals(buffer, position, _rBytes, 0, _crSize) 
        //                        || ByteArrayTools.FastEquals(buffer, position, _nBytes, 0, _crSize);
        //            if (isCrlf)
        //                position + _crSize
        //            else
        //                Find(position - _crSize)
        //        }
        //    }
            
        //    Find(searchFrom - _crSize)
        //}
        
        //private FindNextLineStart(buffer : array[byte], searchFrom : int) : int
        //{
        //    def crSize = _crSize;
        //    def r = _rBytes;
        //    def n = _nBytes;
            
        //    def Find(position, crlfFound)
        //    {
        //        if (position == buffer.Length -1)
        //            position + crSize
        //        else
        //        {
        //            def isCrlf = ByteArrayTools.FastEquals(buffer, position, r, 0, crSize) 
        //                        || ByteArrayTools.FastEquals(buffer, position, n, 0, crSize);
        //            match(isCrlf, crlfFound)
        //            {
        //                | (false, true) => position
        //                | _             => Find(position + crSize, isCrlf)
        //            }
        //        }
        //    }
            
        //    Find(searchFrom, false)                        
        //}
        
        //[TraceMethod]
        //private ParseImpl(parser: BufferParser3, buffer : array[byte], start : int, length : int) : RegexParser.Result
        //{
        //    parser.ParseBuffer(buffer, start, length);
        //}
        
        //[TraceMethod]
        //private ParseBuffer(parser : BufferParser3, buffer : array[byte], len : int) : list[RegexParser.Result]*int
        //{
        //    def partSize = 2048*1024;
        //    def GetParts(position, partList)
        //    {
        //        if (len - position < partSize)
        //        {
        //            (position, len - position) :: partList
        //        }
        //        else
        //        {
        //            def nextPartStart = FindNextLineStart(buffer, position + partSize);
        //            def newPartList = (position, nextPartStart - position) :: partList;
        //            GetParts(nextPartStart, newPartList)
        //        }
        //    }
            
        //    def parts = GetParts(0, []).Reverse().ToArray();            
            
        //    def resArray = array(parts.Length);
            
        //    //foreach(part in parts with i)
        //    //{
        //    //    def part = parts[i];
        //    //    def (start, length) = part;
        //    //    def result = ParseImpl(parser, buffer, start, length);
        //    //    def result = parser.ParseBuffer(buffer, start, length);
        //    //    resArray[i] = result;          
        //    //}
        //    Parallel.For(0, parts.Length,
        //        i =>
        //        {
        //            def part = parts[i];
        //            def (start, length) = part;
        //            def result = ParseImpl(parser, buffer, start, length);
        //            resArray[i] = result;          
        //        });
            
        //    def lastResult = resArray.Last(r => r.ResultCount > 0);
        //    (NList.ToList(resArray), lastResult.LastBytePosition)            
        //}
        
        private readLength = 8*1024*1024;
        private bufferPool : SimpleObjectPool[array[byte]] = SimpleObjectPool.[array[byte]](() => array(readLength));
        
        private ReadAndParseCore(resultCollection : BlockingCollection[Task[RegexParser.Result]]) : void
        {
            def rawLineCollection = BlockingCollection.[Task[CrlfSearcher.Result]](3);
            def rawLineReader = RawLineReader(_stream, _encoding, bufferPool);
            _ = Task.Factory.StartNew(() => rawLineReader.StartReadRawLines(rawLineCollection));

            def regexParser = RegexParser(_encoding, _regexes.ToArray());
            
            foreach(t in rawLineCollection.GetConsumingEnumerable())
            {
                def task = t.ContinueWith(r => regexParser.Parse(r.Result));
                resultCollection.Add(task);
            }

            resultCollection.CompleteAdding();
        }
        
        private ReadAndParse() : BlockingCollection[Task[RegexParser.Result]]
        {
            def collection = BlockingCollection.[Task[RegexParser.Result]](2);
            SkipPreamble();                

            _ = Task.Factory.StartNew(() => ReadAndParseCore(collection), TaskCreationOptions.LongRunning);
            collection
        }
        
        public GetEnumerator() : IEnumerator[ILine]
            implements IEnumerable.[ILine].GetEnumerator
        { 
            mutable offset;
            foreach(task in ReadAndParse().GetConsumingEnumerable())
            {
                def result = task.Result;
                def buffer = result.CrlfsResult.Buffer;
                using (result)
                {
                    for (mutable idx =0; idx < result.ResultCount; idx ++)
                    {
                        def lineStart = result.GetLineStart(idx);
                        def lineLength = result.GetLineLength(idx);
                        def position = result.Position;

                        def stringBuffer = result.StringBuffer;
                        def stringIndices = result.StringIndices;
                        def indicesOffset = result.GetStringIndicesOffset(idx);
                        def groupNameMapping = result.GetGroupNameMapping(idx); 
                        def beginOffset = lineStart :> long + position;
                        def endOffset = lineLength :> long + beginOffset;
                            
                        def line = RegexBasedLine(stringBuffer, stringIndices, indicesOffset, groupNameMapping)
                            <- { Offset = beginOffset; EndOffset = endOffset; }; 
                        offset = line.Offset;
                        yield line
                    }
                }
                bufferPool.Release(buffer);
            }
            
        }

        public NonGenericGetEnumerator() : IEnumerator
            implements IEnumerable.GetEnumerator
        { 
            (this : ILineReader).GetEnumerator() 
        }
        
            private static ReadTextAt(encoding : System.Text.Encoding, stream : Stream, beginOffset : long, endOffset : long) : string*array[byte]
            {
                def length = (endOffset - beginOffset) :> int;

                def buffer    = array(length);

                stream.Position = beginOffset;
                def bytesRead = stream.Read(buffer, 0, length);
            
                (encoding.GetString(buffer, 0, bytesRead).TrimEnd(System.Environment.NewLine.ToCharArray()), buffer);
            }

        [Memoize]
        private GetGroupNamesMapping(regex : Regex) : Dictionary[string, int]
        {
            Enumerable.Zip(regex.GetGroupNames(), regex.GetGroupNumbers(), (name, num)=> (name, num)).ToDictionary(n => n[0], n => n[1]);
        }

        public ReadLineAt(beginOffset : long, endOffset : long) : LogGrok.Core.ILine
        {
            def (str, buffer) = ReadTextAt(_encoding, _lineStream, beginOffset, endOffset);
            
            def ParseLine(regexes, idx)
            {
                | (regex :: rest, _)
                    =>  def mtch = regex.Match(str);
                        if (!mtch.Success)
                            ParseLine(rest, idx + 1)
                        else
                        {
                            def indicesSize =  2 * regex.GetGroupNumbers().Length + 1;
                            def indices = array(indicesSize) : array[int];
                            indices[0] = idx;
                            mutable position = 1;
                            foreach(group : Group in mtch.Groups)
                            {
                                indices[position] = group.Index;
                                indices[position + 1] = group.Length;
                                position += 2;
                            }
                            def line = RegexBasedLine(str, indices, 1, GetGroupNamesMapping(regex));
                            line                                               
                        }
                            
                        
                | _ =>  EmptyLine
            }
            
            ParseLine(_regexes, 0)
//            EmptyLine
            //
            //def parser = LogGrok.Unsafe.BufferParser3(_encoding, _regexes.ToArray());
            //using(def result = _parser.ParseBuffer(buffer, 0, buffer.Length))
            //{
            //    if (result.ResultCount < 1)
            //    {
            //        EmptyLine
            //    }
            //    else
            //    {
            //        def lineStart = result.GetLineStart(0);
            //        def lineLength = result.GetLineLength(0);

            //        def stringBuffer = result.StringBuffer;
            //        def stringIndices = result.StringIndices;
            //        def indicesOffset = result.GetStringIndicesOffset(0);
            //        def groupNameMapping = result.GetGroupNameMapping(0); 
                        
            //        RegexBasedLine(stringBuffer, stringIndices, indicesOffset, groupNameMapping).Clone();
            //    }
            //}
        }

        private static GetFieldAccessor[T,R](fieldName : string ) : Func[T,R]
        { 
            def param = Expression.Parameter (typeof(T),"arg");  

            def member = Expression.Field(param, fieldName);   

            def lambda = Expression.Lambda(typeof(Func[T,R]), member, param);   

            lambda.Compile() :> Func[T,R]; 
        }

        //[Memoize]
        //private GetGroupNamesMapping(regex : Regex) : Dictionary[string, int]
        //{
        //    Enumerable.Zip(regex.GetGroupNames(), regex.GetGroupNumbers(), (name, num)=> (name, num)).ToDictionary(n => n[0], n => n[1]);
        //}
        

        private class EmptyLinePrivate : Line
        {
            public override Item[_ : string] : object { get { Text.Empty } }

            public override Time : System.TimeSpan { get; set; }

            public override GetRawLine() : string { string.Empty }
        }
               
        private _lineStream : Stream;
        private _stream : Stream;
        private _encoding : Encoding;
        
        private _regexes      : list[Regex];
        private _meta         : MetaInformation;
        private _matchesGetter : Func[Match, array[array[int]]] = GetFieldAccessor.[Match, array[array[int]]]("_matches");
        
        public static EmptyLine : Line = EmptyLinePrivate();
    }
}
