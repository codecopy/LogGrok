using Nemerle;

using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Reflection;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Deployment.Application;
using System.IO;

using NLog;

using LogGrok.Diagnostics.Environment;
using LogGrok.Diagnostics.Formatters;

[assembly: log4net.Config.XmlConfigurator(Watch = true)]

namespace LogGrok.Diagnostics
{
  public class Logger
  {
      static this()
      {
          
          _nlogLogger = LogManager.GetCurrentClassLogger();         
          GlobalDiagnosticsContext.Set("EntryAssembly", Assembly.GetEntryAssembly().FullName);
          
          GlobalDiagnosticsContext.Set("DeploymentVersion", if (ApplicationDeployment.IsNetworkDeployed) ApplicationDeployment.CurrentDeployment?.CurrentVersion?.ToString() else string.Empty);
      }
      
      private this(component : string)
      {
          _component = component;
          _loggerFunc = Log4NetLog;
      }
      
      public static Get(component : string = null) : Logger
      {
          def comp = component ?? ComponentProvider.DetectCurrentComponent();
          _loggersCache.GetOrAdd(comp, c => Logger(c));
      }
      
      public static FlushAll() : void
      {
          //LogManager.Flush();   
      }
            
      public Debug(message : string, params args : array[object]) : void
      {
          Log(LogLevel.Debug, message, args);
      }
      
      public Info(message : string, params args : array[object]) : void
      {
          Log(LogLevel.Info, message, args);
      }  
      
      public Warn(message : string, params args : array[object]) : void
      {
          Log(LogLevel.Warn, message, args);
      }
      
      public Error(message : string, params args : array[object]) : void
      {
          Log(LogLevel.Error, message, args);
      }
      
      public Flush() : void
      {
         // LogManager.Flush();   
      }
      
      private Log(level : LogLevel, message : string, args : array[object]) : void
      {
            _loggerFunc(level, message, args)   
      }
      
      private NLogLog(level : LogLevel, message : string, args : array[object]) : void
      {
          def logEvent = LogEventInfo.Create(level, _nlogLogger.Name, null, message, args);
          
          logEvent.Properties["component"] = _component;
          logEvent.Properties["levelShort"] = LogLevelFormatter.Format(level);
          
          _nlogLogger.Log(logEvent);                    
      }
      
      private Log4NetLog(level : LogLevel, message : string, args : array[object]) : void
      {
          def msg = string.Format(message, args);
          match(level)
          {
            |  _ when level == LogLevel.Info  => _log4netLogger.Info(msg)
            |  _ when level == LogLevel.Warn  => _log4netLogger.Warn(msg)
            |  _ when level == LogLevel.Error => _log4netLogger.Error(msg)           
            |  _ when level == LogLevel.Debug => _log4netLogger.Debug(msg)
          } 
      }
      
      private _component : String;
            
      private _loggerFunc : (LogLevel * string * array[object]) -> void;
      
      private static _loggersCache : ConcurrentDictionary[string, Logger] = ConcurrentDictionary();
      private static _nlogLogger : NLog.Logger;   
      
      private static _log4netLogger : log4net.ILog = log4net.LogManager.GetLogger(typeof(Logger));
      
  }
}
